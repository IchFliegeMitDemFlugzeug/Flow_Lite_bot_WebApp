<?xml version="1.0" encoding="UTF-8"?> <!-- Заголовок XML: кодировка UTF-8, чтобы кириллица в именах правил не ломалась -->
<configuration> <!-- Корневой элемент конфигурации IIS -->

    <system.webServer> <!-- Раздел настроек веб-сервера IIS (всё, что влияет на обработку запросов/ответов) -->

        <rewrite> <!-- Блок модуля "Переопределение URL-адресов" (URL Rewrite): правила входящих запросов + правила исходящих заголовков -->

            <rules> <!-- ВХОДЯЩИЕ правила (что делать с URL, которые приходят в IIS) -->

                <rule name="HTTP -> HTTPS (301)" stopProcessing="true"> <!-- Правило: если пришли по HTTP, отправляем на HTTPS; stopProcessing=true — дальше правила не проверяем -->
                    <match url="(.*)" /> <!-- Совпадает с любым URL-путём (всё, что после домена) -->
                    <conditions> <!-- Условия, при которых правило сработает -->
                        <add input="{HTTPS}" pattern="^OFF$" /> <!-- Условие: если соединение НЕ HTTPS (HTTPS=OFF) -->
                    </conditions> <!-- Конец блока условий -->
                    <action type="Redirect" url="https://{HTTP_HOST}/{R:1}" /> <!-- Действие: редирект на HTTPS, сохраняя хост и путь (R:1 — то, что поймали match) -->
                </rule> <!-- Конец правила HTTP -> HTTPS -->

                <rule name="Редирект с WWW"> <!-- Правило для www.potok-crm.ru -->
                    <match url="(.*)" /> <!-- Совпадает с любым путём -->
                    <conditions> <!-- Условия правила -->
                        <add input="{HTTP_HOST}" pattern="^www\.potok-crm\.ru$" /> <!-- Условие: если хост ровно www.potok-crm.ru -->
                    </conditions> <!-- Конец условий -->
                    <action type="Rewrite" url="https://potok-crm.ru/{R:1}" logRewrittenUrl="true" /> <!-- Действие: переписываем на основной домен; (оставлено как у тебя, чтобы ничего не сломать) -->
                </rule> <!-- Конец правила WWW -->

                <rule name="Взаимодействие фронт-бэк" stopProcessing="true"> <!-- Правило прокси: всё /api/* уходит на Python backend; stopProcessing=true — дальше правила не проверяем -->
                    <match url="^api/(.*)" /> <!-- Совпадает с путём, начинающимся с api/ (без начального слэша, так работает URL Rewrite) -->
                    <action type="Rewrite" url="http://127.0.0.1:8080/api/{R:1}" /> <!-- Прокидываем запрос внутрь на localhost:8080 сохраняя хвост пути -->
                </rule> <!-- Конец правила прокси /api -->

            </rules> <!-- Конец входящих правил -->

            <outboundRules> <!-- ИСХОДЯЩИЕ правила (меняем заголовки ответов IIS; это и есть "профессиональное кэширование") -->

                <!-- ========================= -->
                <!-- 1) API: НИКОГДА не кэшировать -->
                <!-- ========================= -->

                <rule name="Cache-Control для API (no-store)" preCondition="IsApiRequest"> <!-- Правило: для любых ответов на /api/* ставим no-store -->
                    <match serverVariable="RESPONSE_Cache_Control" pattern=".*" /> <!-- Матчимся по текущему заголовку Cache-Control (любой), чтобы гарантированно перезаписать -->
                    <action type="Rewrite" value="no-store, no-cache, must-revalidate, max-age=0" /> <!-- Ставим жёсткий запрет кэширования (важно для WebApp и мгновенных обновлений) -->
                </rule> <!-- Конец правила Cache-Control для API -->

                <rule name="Pragma для API (no-cache)" preCondition="IsApiRequest"> <!-- Доп.совместимость со старыми/прокси: Pragma -->
                    <match serverVariable="RESPONSE_Pragma" pattern=".*" /> <!-- Перезаписываем Pragma -->
                    <action type="Rewrite" value="no-cache" /> <!-- Проставляем no-cache -->
                </rule> <!-- Конец Pragma для API -->

                <rule name="Expires для API (0)" preCondition="IsApiRequest"> <!-- Доп.совместимость: Expires -->
                    <match serverVariable="RESPONSE_Expires" pattern=".*" /> <!-- Перезаписываем Expires -->
                    <action type="Rewrite" value="0" /> <!-- Expires=0 (считается "просрочено") -->
                </rule> <!-- Конец Expires для API -->

                <!-- ========================= -->
                <!-- 2) HTML: НИКОГДА не кэшировать (чтобы обновления виделись сразу) -->
                <!-- ========================= -->

                <rule name="Cache-Control для HTML (no-store)" preCondition="IsHtmlResponse"> <!-- Правило: для HTML-страниц запрещаем кэш -->
                    <match serverVariable="RESPONSE_Cache_Control" pattern=".*" /> <!-- Перезаписываем Cache-Control -->
                    <action type="Rewrite" value="no-store, no-cache, must-revalidate, max-age=0" /> <!-- HTML должен приходить свежим, иначе Telegram/WebView может показывать старую оболочку -->
                </rule> <!-- Конец Cache-Control для HTML -->

                <rule name="Pragma для HTML (no-cache)" preCondition="IsHtmlResponse"> <!-- Проставляем Pragma на HTML -->
                    <match serverVariable="RESPONSE_Pragma" pattern=".*" /> <!-- Перезаписываем Pragma -->
                    <action type="Rewrite" value="no-cache" /> <!-- Pragma=no-cache -->
                </rule> <!-- Конец Pragma для HTML -->

                <rule name="Expires для HTML (0)" preCondition="IsHtmlResponse"> <!-- Проставляем Expires на HTML -->
                    <match serverVariable="RESPONSE_Expires" pattern=".*" /> <!-- Перезаписываем Expires -->
                    <action type="Rewrite" value="0" /> <!-- Expires=0 -->
                </rule> <!-- Конец Expires для HTML -->

                <!-- ========================= -->
                <!-- 3) Статика: кэшировать ДОЛГО (быстро в WebApp), но обновления через ?v=... -->
                <!-- ========================= -->

                <rule name="Cache-Control для статики (1 год, immutable)" preCondition="IsStaticAssetRequest"> <!-- Правило: для JS/CSS/картинок/шрифтов ставим долгий кэш -->
                    <match serverVariable="RESPONSE_Cache_Control" pattern=".*" /> <!-- Перезаписываем Cache-Control -->
                    <action type="Rewrite" value="public, max-age=31536000, immutable" /> <!-- 31536000 секунд = 1 год; immutable говорит WebView не проверять лишний раз -->
                </rule> <!-- Конец Cache-Control для статики -->

                <!-- ========================= -->
                <!-- Предусловия (когда применять правила) -->
                <!-- ========================= -->

                <preConditions> <!-- Блок предикатов (условий), чтобы правила выше применялись только к нужным ответам -->

                    <preCondition name="IsApiRequest"> <!-- Предусловие: запрос относится к API -->
                        <add input="{REQUEST_URI}" pattern="^/api/" /> <!-- Если путь начинается с /api/ — это API -->
                    </preCondition> <!-- Конец IsApiRequest -->

                    <preCondition name="IsHtmlResponse"> <!-- Предусловие: ответ является HTML -->
                        <add input="{RESPONSE_CONTENT_TYPE}" pattern="^text/html" /> <!-- Если Content-Type начинается с text/html — это HTML -->
                    </preCondition> <!-- Конец IsHtmlResponse -->

                    <preCondition name="IsStaticAssetRequest"> <!-- Предусловие: запрос к статике (файлы из Flow_Lite_bot_WebApp_Frontend/js, /css, /assets, /redirect, /styles и т.п.) -->
                        <add input="{REQUEST_URI}" pattern="\.((js)|(css)|(png)|(jpg)|(jpeg)|(gif)|(svg)|(webp)|(ico)|(woff)|(woff2)|(ttf)|(otf)|(map))$" /> <!-- По расширениям определяем статику -->
                    </preCondition> <!-- Конец IsStaticAssetRequest -->

                </preConditions> <!-- Конец блока предикатов -->

            </outboundRules> <!-- Конец исходящих правил (кэширование) -->

        </rewrite> <!-- Конец модуля rewrite -->

    </system.webServer> <!-- Конец system.webServer -->

</configuration> <!-- Конец configuration -->
