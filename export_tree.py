import os  # Импортируем модуль os для работы с файловой системой (папки, файлы, пути)

# ---------- НАСТРОЙКИ ----------

PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
# PROJECT_ROOT – путь к корню проекта.
# os.path.abspath(__file__) – абсолютный путь к этому файлу (export_tree.py).
# os.path.dirname(...) – берём папку, в которой лежит этот файл.
# То есть, считаем корнем проекта ту папку, где находится export_tree.py.

OUTPUT_FILE = os.path.join(PROJECT_ROOT, "project_tree.txt")
# OUTPUT_FILE – полный путь к файлу, в который мы запишем структуру проекта.
# os.path.join(...) аккуратно собирает путь под любую ОС.

IGNORE_DIRS = {
    ".git",
    ".idea",
    ".venv",
    "venv",
    "__pycache__",
    ".mypy_cache",
    ".pytest_cache",
    ".vscode",
}
# IGNORE_DIRS – множество (set) имён ПАПОК, которые будем пропускать при обходе.
# Сюда добавляем всё, что не нужно для понимания структуры:
#   - .git          – служебная папка git
#   - .idea         – настройки PyCharm
#   - .venv / venv  – виртуальные окружения
#   - __pycache__   – скомпилированные .pyc файлы
#   - прочий кэш редакторов / инструментов

IGNORE_FILES = {
    ".DS_Store",
}
# IGNORE_FILES – множество имён ФАЙЛОВ, которые можно игнорировать.
# Сейчас тут только .DS_Store (служебный файл macOS),
# при желании можно добавить свои.


def build_tree(root_path: str, prefix: str = "") -> list[str]:
    """
    Рекурсивно строит дерево файлов и папок, начиная с root_path.
    Возвращает список строк, каждая строка – одна строка будущего дерева.
    prefix – текстовый префикс перед элементами (веточки ├──, │   и т.п.).
    """
    # Получаем список всех элементов (файлы + папки) внутри root_path
    entries = os.listdir(root_path)

    # Разделяем на папки и файлы
    dirs = []
    files = []

    for name in entries:
        # Полный путь к элементу
        full_path = os.path.join(root_path, name)

        # Если это папка
        if os.path.isdir(full_path):
            # Проверяем, не находится ли имя папки в списке игнорируемых
            if name not in IGNORE_DIRS:
                dirs.append(name)  # Добавляем папку в список папок
        else:
            # Если это файл – проверяем, не в списке ли игнорируемых файлов
            if name not in IGNORE_FILES:
                files.append(name)  # Добавляем файл в список файлов

    # Сортируем папки и файлы по имени, чтобы дерево выглядело аккуратно
    dirs.sort()
    files.sort()

    # Объединяем папки и файлы в один список, чтобы пройти по нему и рисовать ветки
    items = dirs + files

    lines: list[str] = []  # Здесь будем накапливать строки дерева для текущего уровня

    for index, name in enumerate(items):
        # full_path – полный путь к текущему элементу
        full_path = os.path.join(root_path, name)

        # last_item – флаг: последний ли это элемент в списке items
        last_item = (index == len(items) - 1)

        # Если элемент последний, рисуем ответвление "└──", иначе "├──"
        branch = "└── " if last_item else "├── "

        # Формируем строку с префиксом (│   или пробелы) + веткой + именем
        line = f"{prefix}{branch}{name}"
        lines.append(line)

        # Если текущий элемент – папка, нужно рекурсивно обойти её содержимое
        if os.path.isdir(full_path):
            # Для дочернего уровня префикс зависит от того, был ли текущий элемент последним
            # Если элемент последний – дальше идёт "    " (пустое пространство)
            # Если не последний – дальше идёт "│   " (вертикальная линия)
            child_prefix = f"{prefix}{'    ' if last_item else '│   '}"

            # Рекурсивно строим дерево для вложенной папки
            child_lines = build_tree(full_path, child_prefix)

            # Добавляем строки дочернего уровня в общий список
            lines.extend(child_lines)

    return lines  # Возвращаем список строк для текущего уровня дерева


def main() -> None:
    """
    Точка входа в скрипт.
    Строит дерево проекта и записывает его в файл OUTPUT_FILE.
    """
    # Имя корневой папки (последняя часть пути к проекту)
    root_name = os.path.basename(PROJECT_ROOT) or PROJECT_ROOT
    # os.path.basename(...) берёт последнее имя в пути (например, "Flow_Lite_bot").
    # Если по какой-то причине оно пустое – используем PROJECT_ROOT целиком.

    # Начинаем список строк с имени корневой папки (без веток ├──)
    lines = [root_name]

    # Получаем дерево для всего содержимого корня
    tree_lines = build_tree(PROJECT_ROOT)

    # Добавляем полученные строки в общий список
    lines.extend(tree_lines)

    # Открываем файл OUTPUT_FILE в режиме записи с кодировкой UTF-8
    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        # Записываем все строки в файл, разделяя их переводом строки "\n"
        f.write("\n".join(lines))

    # Печатаем в консоль, куда записан файл – просто для удобства
    print(f"Структура проекта записана в файл: {OUTPUT_FILE}")


# Стандартная конструкция для запуска main() только если файл
# запущен как скрипт, а не импортирован как модуль
if __name__ == "__main__":
    main()
